## 垃圾收集算法

#### 1 标记-清除算法（Mark-Sweep）

##### 1.1 算法思想

* 算法分为两个阶段：标记、清除；
* 首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

##### 1.2 图示

<img src="images.assets/1585745036400.png" alt="1585745036400" style="zoom: 80%;" />

##### 1.3 存在问题

* 效率问题

  标记和清除两个过程效率都不高，因为有大量垃圾存在时，需要一个个标记和清除，假设空间 99% 都是垃圾，那么需要清除 99% 的空间，那么为啥不反过来直接保留存活的 1% 对象呢。

* 空间问题

  标记清除后会产生大量不连续的内存碎片，空间碎片多可能会导致以后程序运行时需要分配大对象时，无法找到足够连续内存导致提前触发另一次垃圾收集动作。

#### 2 复制算法（Copying）

##### 2.1 算法思想

将可用内存按容量分为大小相等的两块，每次只使用其中的一块。当这块内存使用完，就将还存活的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。

##### 2.2 优缺点

每次只对半区进行内存回收，内存分配不用考虑空间碎片问题。

可用内存缩小为一半，浪费空间。

这个操作适用于存活对象比例少的情况，因为复制时候只需要复制少量的对象，不需要像标记清除算法面对大量垃圾对象长时间耗时回收。

##### 2.3 图示

<img src="images.assets/1585746048464.png" alt="1585746048464" style="zoom: 80%;" />

##### 2.4 新生代区域

HotSpot虚拟机**堆**内存的**新生代**划分为较大的 **Eden** 空间和两块较小的 **Survivor** 空间，每次使用 Eden 和其中一个 Survivor 。

![1585746783525](images.assets/1585746783525.png)

当回收时，将Eden 和 Survivor 中还存活的对象一次性复制到另外一块 Survivor 空间上，最后清理掉 Eden 和 刚才使用过的 Survivor 空间。HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 **8:1**，即每次新生代可用内存容量为 80% + 10% = 90%。

但是每次 Eden 和 一个 Survivor 存活的对象不可能都小于 10%，即可能一次存活的对象较多，另一个 Survivor 空间放不下，那么就需要通过分配担保机制直接进入老年代。

