## 垃圾收集算法

#### 1 标记-清除算法（Mark-Sweep）

##### 1.1 算法思想

* 算法分为两个阶段：标记、清除；
* 首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

##### 1.2 图示

<img src="images.assets/1585745036400.png" alt="1585745036400" style="zoom: 80%;" />

##### 1.3 存在问题

* 效率问题

  标记和清除两个过程效率都不高，因为有大量垃圾存在时，需要一个个标记和清除，假设空间 99% 都是垃圾，那么需要清除 99% 的空间，那么为啥不反过来直接保留存活的 1% 对象呢。

* 空间问题

  标记清除后会产生大量不连续的内存碎片，空间碎片多可能会导致以后程序运行时需要分配大对象时，无法找到足够连续内存导致提前触发另一次垃圾收集动作。

#### 2 复制算法（Copying）

##### 2.1 算法思想

将可用内存按容量分为大小相等的两块，每次只使用其中的一块。当这块内存使用完，就将还存活的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。

##### 2.2 优缺点

每次只对半区进行内存回收，内存分配不用考虑空间碎片问题。

可用内存缩小为一半，浪费空间。

这个操作适用于存活对象比例少的情况，因为复制时候只需要复制少量的对象，不需要像标记清除算法面对大量垃圾对象长时间耗时回收。

如果存活对象较多也不适合，需要进行较多的复制操作，效率变低。

##### 2.3 图示

<img src="images.assets/1585746048464.png" alt="1585746048464" style="zoom: 80%;" />

##### 2.4 新生代区域

HotSpot虚拟机**堆**内存的**新生代**划分为较大的 **Eden** 空间和两块较小的 **Survivor** 空间，每次使用 Eden 和其中一个 Survivor 。

![1585746783525](images.assets/1585746783525.png)

当回收时，将Eden 和 Survivor 中还存活的对象一次性复制到另外一块 Survivor 空间上，最后清理掉 Eden 和 刚才使用过的 Survivor 空间。HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 **8:1**，即每次新生代可用内存容量为 80% + 10% = 90%。

但是每次 Eden 和 一个 Survivor 存活的对象不可能都小于 10%，即可能一次存活的对象较多，另一个 Survivor 空间放不下，那么就需要通过分配担保机制直接进入老年代。

#### 3 标记-整理算法（Mark-Compact）

##### 3.1 算法思想

标记过程仍然和“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

##### 3.2 图示

<img src="images.assets/1585747436962.png" alt="1585747436962" style="zoom: 80%;" />

#### 4 分代收集算法

商业虚拟机采用“**分代收集**”（Generational Collection）算法，即根据对象存活周期的不同将内存划分为几块，一般把堆分为新生代和老年代，根据各个年代的特点采用最适当的收集算法。

* **新生代**中每次垃圾收集时都有大量对象死去，只有少量存活，并且有老年代可分配担保，适合**复制**算法；

* **老年代**对象存活率高，没有额外空间可分配担保，就要使用 **标记-清理** 或者 **标记-整理** 算法进行回收。