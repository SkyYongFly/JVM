# Java内存区域与内存溢出异常

## 1  运行时数据区域

### 1.1 **基本概念**

​	Java本身也是个应用程序，需要占用实际物理内存，Java对自身分配到的这部分内存区域根据用途进行划分。

### 1.2 **内存区域分配**

​	根据《Java虚拟机规范（Java SE 7版）》规定：

<img src="memory.assets/1584972435134.png" alt="1584972435134" style="zoom:80%;" />

- **概述**

  - JVM将分配到的内存分为**堆、方法区、虚拟栈、本地方法栈、程序计数器** 5个基本区域（具体实际不同虚拟机、相同虚拟机的不同版本实现有差别）；
  - 线程**共享**的区域：方法区、堆；比如所有不同线程中创建的对象实例一般都存放到堆中；
  - 线程**私有**的区域：虚拟栈、本地方法栈、程序计数器；例如不同线程执行时候在虚拟机栈中会创建不同的栈实例；
  - 虚拟机执行引擎作为具体的执行者，肯定要访问内存获取存放数据了；
  - 在执行本地 Native 方法的时候会使用到本地方法栈；

- **详细内存区域分配**

  ![1584974753425](memory.assets/1584974753425.png)

### 1.3 程序计数器

* **内容**

  * **程序计数器（Program Counter Register）**: 当前线程所执行的字节码的行号指示器，字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令。

  * 多线程每条线程都有一个独立的程序计数器，之间互不影响，独立存储，所以说程序计数器内存区域为“线程私有内存”。

  * 如果线程正在执行的是Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是Native本地方法，计数器值为空（Undefined）。

  * Java虚拟机规范对此区域没有规定 OutOfMemoryError 情况，即可以任务此区域不会 OOM 。

* **理解**

  我们平时写的代码文件格式都是 **.java，会经过编译器编译成class字节码文件，虚拟机识别并读取的就是class文件。

  我们知道程序运行本质上就是通过编译后的一条条指令来调用底层操作系统等相关内容来实现的，例如计算 int  a = 1 + 3，那么这个会经过编译，高级语言编译成底层C、汇编直到最原始的二进制计算机指令，加载数据给CPU寄存器，经过运算器运算，最终数据返回到内存，内核空间返回到用户空间，在虚拟机层面进行变量赋值等操作。

  Java代码编译后的class字节码文件本质上其实就是一行行代码指令构成，例如：

  ```java
  package com.skylaker.jvm;
  
  public class TestService {
      public static void main(String[] args) {
          int a = 1 + 3;
          System.out.println("Yes , JVM !");
      }
  }
  ```

  编译后的字节码文件内容 （在IDEA中如果直接点击class文件查看其实是经过反编译的，相当于又将字节码指令翻译回源代码格式了，这里我们要直接查看class本身内容，可以安装 jclasslib 插件，也可以直接通过javap命令）:

  ![1585365858144](memory.assets/1585365858144.png)

  可以看到编译后的字节码指令都有对应的行号标识。只不过class字节码指令属于高级语言程序指令而已，从虚拟机层面运行肯定要依次按照设定去顺序读取这些指令（这个执行器不一样可能不同），并且程序中会有分支 if-else、跳转 break等操作，那么虚拟机如何知道下一条需要执行的指令呢，不然不是迷路了么？其实和我们用便签记录代办事项类似，当前做的、后续要做的事情我记录一下，程序计数器就是记录指令行号（更准确的说是指令地址）来确定程序执行位置。

### 1.4 Java虚拟机栈

* **内容**

  * **Java虚拟机栈（Java Virtual Machine Stacks）**：描述的是Java方法执行的内存模型，每个方法执行的同时会创建一个栈帧（Stack Frame）拥有存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用直至执行完成的过程，就对应一个栈帧在虚拟机栈中入栈到出栈的过程。

  * 线程私有区域，生命周期与线程相同。
  * Java虚拟机规范对此区域定义两种异常状况：
    * 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverFlowError异常（栈溢出）；
    * 如果虚拟机栈扩展时候无法申请足够的内存，将抛出OutOfMemoryError异常（内存溢出）。

* **理解**

  我们可以先看下虚拟机栈的内存图示：

  <img src="memory.assets/1585368099095.png" alt="1585368099095" style="zoom:80%;" />

  我们先不用纠结这个栈帧和里面的内容，这些在后续的学习中会详细涉及。这里我们需要知道的就是线程在执行方法时候会有对应的栈帧放入自己对应的虚拟机栈中。

  我们知道Java在执行时候其实是对应的线程在执行，即使没有显式的开启线程，也会有隐式的主线程在运行。线程运行程序最直观的无非调用方法，比如从main方法开始，调用方法A，方法A又调用方法B，这么依次调用再返回。而在执行不同方法时候，一个需要给当前方法执行所需要的资源创建空间去操作，一个需要知道方法执行前后的返回路径，不至于调用了方法B，方法B执行完后不知道返回到哪个方法继续执行。前一个问题就是对应创建一个栈帧，这个栈帧直白点理解成一个内存区域，存放着我们方法中定义的局部变量等信息，第二个问题就是利用栈这个数据结构，先执行的方法栈帧在栈下面，后执行的在上面，比如A调用B，A 的栈帧在 B 栈帧下面，当 B方法执行完，那么 B 栈帧出栈，直接返回下面的栈帧对应方法执行，就是继续执行 A 方法，而不用利用一个集合啥的去到处记录谁调用谁啥的，很简便快捷。

  每个线程调用方法肯定是不同场景的，线程1调用方法 A，可能其中的变量 name 是 小花，线程 2 调用同样的方法 A，可能 变量 name 就变成 小明 了，所以每个线程需要单独分配自己的虚拟机栈运行。

### 1.5 本地方法栈

* **内容**

  * **本地方法栈（Native Method Stack）**:  作用类似虚拟机栈，只不过虚拟机栈用于执行Java方法，而本地方法栈用于虚拟机调用本地Native方法。

  * 虚拟机规范对本地方法栈的具体实现没有规定，即不同虚拟机可以自由实现，而 HotSpot虚拟机直接把本地方法栈和虚拟机栈合二为一。

  * 本地方法栈也会抛出 StackOverFlowError 和 OutOfMemoryError 异常。

### 1.6 Java堆

* **内容**

  * **Java堆（Heap）**：用于存放对象**实例**以及**数组**，在虚拟机启动时候创建，是所有线程共享的内存区域。

  * Java堆是垃圾收集器管理的主要区域，因此也被称为 **GC堆**，Java堆可以细分为新生代和老年代，采用分代垃圾收集算法。

  * Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），但是存储的仍然是对象实例。

  * Java堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可，实现时可以设置成固定大小，也可动态扩展。

  * 堆中无内存可以再分配，抛出 OutOfMemoryError异常。

* **图示**

  Java堆详细分区布局：

  <img src="memory.assets/1585370186571.png" alt="1585370186571" style="zoom:80%;" />

  更为详细的内容第2章节涉及。

### 1.7 方法区

* **内容**
  * **方法区（Method Area**）: 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
  * HotSpot虚拟机上方法区习惯被称为“永久代”（Permanent Generation），本质上两者并不等价，仅因为HotSpot虚拟机选择把GC分代收集器扩展至方法区，或者说用永久代来实现方法区而已，因为这样可以直接像管理Java堆一样管理方法区，避免专门编写内存管理相关代码。
  * 如何实现方法区属于虚拟机实现细节，不受虚拟机规范约束。
  * 该区域垃圾回收的目标主要针对常量池的回收和堆类型的卸载。
  * 虚拟机规范规定，方法区无法满足内存分配需求时，抛出 OutOfMemoryError 异常。
  * JDK7已经将方法区中的字符串常量池移出，JDK8已经采用元数据区代替方法区。

### 1.8 运行时常量池

* **内容**
  * 运行时常量池（Runtime Constant Pool）:  是方法区一部分，用于保存 class 字节码文件中描述的符号引用、各种字面量，还会把翻译出来的直接引用也存储再运行时常量池。
  * Class 文件除了类的版本、字段、方法、接口等描述信息外，还有一项是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后进入方法区的运行时常量池。
  * 虚拟机规范没有对运行时常量池做细节要求，不同虚拟机可以自行实现。
  * 运行时常量池具有动态性，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，例如 String 类的 intern() 方法。
  * 运行时常量池受方法区内存限制，常量池无法再申请内存时候会抛出 OutOfMemoryError 异常。


### 1.9 直接内存

* 内容
  * 直接内存（Direct Memory）:  并不是虚拟机运行时数据区的一部分，也不是虚拟机规范定义的内存区域，但是也可能导致 OutOfMemoryError 异常。
  * JDK1.4 引入的 NIO（New Input/Output）类，引入基于通道（Channel）与缓冲区（Buffer）的I/O方式，使用Native 函数库直接分配堆外内存，通过存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样操作可提升性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。
  * 直接内存不受 Java堆的大小限制，但是本身也是内存区域，也会收到物理总内存及处理器寻址空间限制，直接内存占用太大，使得加上虚拟机内存等总和超出物理内存限制，会出现 OutOfMemoryError 异常。

* **理解**

  可以简单理解直接内存就是在 Java 虚拟机占用内存外部空间开辟的内存区域，不受 Java 虚拟机本身大小这些限制。单独开辟堆外内存的目的主要是为了提升性能，例如 NIO 中使用直接内存提升了性能，为啥呢？因为传统的阻塞型 BIO 采用流的方式处理数据，假设要从磁盘 A 读取一个文件的数据复制到磁盘 B， BIO 的操作流程：

  <img src="memory.assets/1585385225751.png" alt="1585385225751" style="zoom:80%;" />

  Java层面想要发起这么一个操作请求，本身虚拟机肯定不可能直接和磁盘通信获取数据，需要把读请求发送给操作系统层面，由操作系统发起读数据的指令，硬件接口层获取数据，数据复制到操作系统内核空间，最后数据再复制到虚拟机的空间中，然后还需要将数据写出到磁盘 B，而这个过程又是用户空间到内核空间再到磁盘的几个步骤操作。而 NIO 可以直接使用直接内存快速复制数据，通过减少内核空间到用户空间的复制操作提升效率，另外本身数据不用在虚拟机层面缓存，也释放了虚拟机内存压力：

  <img src="memory.assets/1585385498526.png" alt="1585385498526" style="zoom:80%;" />

## 2  HotSpot虚拟机对象

### 2.1 对象创建

### 2.2 对象内存布局

### 2.3 对象访问定位

## 3  实战内存溢出异常

### 3.1 堆溢出

### 3.2 虚拟机栈和本地方法栈溢出

### 3.3 方法区和运行时常量池溢出

### 3.4 本机直接内存溢出

