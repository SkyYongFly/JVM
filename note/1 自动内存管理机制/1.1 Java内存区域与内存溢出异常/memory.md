# Java内存区域与内存溢出异常

## 1  运行时数据区域

### 1.1 **基本概念**

​	Java本身也是个应用程序，需要占用实际物理内存，Java对自身分配到的这部分内存区域根据用途进行划分。

### 1.2 **内存区域分配**

​	根据《Java虚拟机规范（Java SE 7版）》规定：

<img src="memory.assets/1584972435134.png" alt="1584972435134" style="zoom:80%;" />

- **概述**

  - JVM将分配到的内存分为**堆、方法区、虚拟栈、本地方法栈、程序计数器** 5个基本区域（具体实际不同虚拟机、相同虚拟机的不同版本实现有差别）；
  - 线程**共享**的区域：方法区、堆；比如所有不同线程中创建的对象实例一般都存放到堆中；
  - 线程**私有**的区域：虚拟栈、本地方法栈、程序计数器；例如不同线程执行时候在虚拟机栈中会创建不同的栈实例；
  - 虚拟机执行引擎作为具体的执行者，肯定要访问内存获取存放数据了；
  - 在执行本地 Native 方法的时候会使用到本地方法栈；

- **详细内存区域分配**

  ![1584974753425](memory.assets/1584974753425.png)

### 1.3 程序计数器

* **内容**

  程序计数器（Program Counter Register）: 当前线程所执行的字节码的行号指示器，字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令。

  多线程每条线程都有一个独立的程序计数器，之间互不影响，独立存储，所以说程序计数器内存区域为“线程私有内存”。

  如果线程正在执行的是Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是Native本地方法，计数器值为空（Undefined）。

  Java虚拟机规范对此区域没有规定 OutOfMemoryError 情况，即可以任务此区域不会 OOM 。

* **理解**

  我们平时写的代码文件格式都是 **.java，会经过编译器编译成class字节码文件，虚拟机识别并读取的就是class文件。

  我们知道程序运行本质上就是通过编译后的一条条指令来调用底层操作系统等相关内容来实现的，例如计算 int  a = 1 + 3，那么这个会经过编译，高级语言编译成底层C、汇编直到最原始的二进制计算机指令，加载数据给CPU寄存器，经过运算器运算，最终数据返回到内存，内核空间返回到用户空间，在虚拟机层面进行变量赋值等操作。

  Java代码编译后的class字节码文件本质上其实就是一行行代码指令构成，例如：

  ```java
  package com.skylaker.jvm;
  
  public class TestService {
      public static void main(String[] args) {
          int a = 1 + 3;
          System.out.println("Yes , JVM !");
      }
  }
  ```

  编译后的字节码文件内容 （在IDEA中如果直接点击class文件查看其实是经过反编译的，相当于又将字节码指令翻译回源代码格式了，这里我们要直接查看class本身内容，可以安装 jclasslib 插件，也可以直接通过javap命令）:

  ![1585365858144](memory.assets/1585365858144.png)

  可以看到编译后的字节码指令都有对应的行号标识。只不过class字节码指令属于高级语言程序指令而已，从虚拟机层面运行肯定要依次按照设定去顺序读取这些指令（这个执行器不一样可能不同），并且程序中会有分支 if-else、跳转 break等操作，那么虚拟机如何知道下一条需要执行的指令呢，不然不是迷路了么？其实和我们用便签记录代办事项类似，当前做的、后续要做的事情我记录一下，程序计数器就是记录指令行号（更准确的说是指令地址）来确定程序执行位置。

### 1.4 本地方法栈

### 1.5 Java堆

### 1.6 方法区

### 1.7 运行时常量池

### 1.8 直接内存

## 2  HotSpot虚拟机对象

### 2.1 对象创建

### 2.2 对象内存布局

### 2.3 对象访问定位

## 3  实战内存溢出异常

### 3.1 堆溢出

### 3.2 虚拟机栈和本地方法栈溢出

### 3.3 方法区和运行时常量池溢出

### 3.4 本机直接内存溢出

