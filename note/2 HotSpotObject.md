## HotSpot虚拟机对象

### 1 对象创建

#### 1.1 **基本流程**

<img src="images.assets/1585390473207.png" alt="1585390473207" style="zoom:80%;" />

#### 1.2 **过程详细描述**

- 语言层面创建一个普通对象一般通过 new 关键字，例如 

  ```java
  TestService service = new com.skylaker.jvm.TestService();
  ```

- **首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用**。

  其实直白点理解就是，我要去创建一个类的对象实例，比如上面这个写法，那总得先存在这个类的定义吧，不然如何创建？皮之不存，毛将焉附？

- **没有被加载过，就需要先执行类加载**。

  比如说上面这个代码要去创建 TestService 类的实例，但是常量池中并不存在这个类的字节码文件内容，那么就需要类加载器将我们源代码编译后的字节码文件 TestService.class 文件加载到虚拟机内存的方法区中，这样才能知道这个类定义的相关信息，从而去创建对象。

- **类加载检查通过后，虚拟机为新生的对象分配内存**。

  为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。有两种方式：指针碰撞、空闲列表：
  
- **指针碰撞（Bump the Pointer）**: 假设 Java 堆中内存是绝对规整的，所有用过的内存都放到一边，空闲的内存放到另一边，中间放着与i个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲那边挪动一段与对象大小相等的距离。
  - **空闲列表（Free List）**：如果堆中的内存并不规整，已使用的内存和空闲的内存相互交错，虚拟机需要维护一个列表，记录哪些内存块是可用的，再分配的时候从列表中找到一个足够大的空间划分给对象实例，并更新列表上的记录。

  而具体哪种方式取决于Java堆**是否规整**，而堆是否规整由采用的**垃圾收集器**是否带有**压缩整理**功能决定。例如使用 Serial、ParNew 等带 Compant 过程的收集器时，系统采用指针碰撞算法，而使用 CMS 这种基于 Mark-Sweep（标记清除）算法时候采用空闲列表算法（因为标记清除算法不进行空间整理，会产生空间碎片，不是规整的内存，所有不好用指针碰撞算法）。
  
  
  
  **对象创建线程安全问题**：例如修改一个指针指向的位置，并发情况下可能出现正在给对象 A 分配内存，指针还未来得及修改，对象 B 使用了原本 A 要使用的内存。解决方案有两种：
  
  * 对分配内存空间的动作进行**同步**处理；
  * 把内存分配的动作按照线程划分再**不同的空间**之中，即每个线程在 Java堆中预先分配一小块内存——称为**本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）**。哪个线程要分配，就在哪个线程的 TLAB 上分配。
  
  其实这个解决方案就是类似解决并发冲突的手段，一种直接加锁控制，一种不共享变量，每个线程单独操作自己的变量，也就不存在线程安全问题了。

* **内存分配完成，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）**。

  保证对象实例字段在 Java 代码种可以不赋初始值就能直接使用，程序能访问到字段数据类型对应零值。

  这个其实例如：`int a = 3;`    a 变量被 赋值为 3，但在这一步先分配变量为对应的 int 类型的初始值 0 。我们程序种可以这样定义变量：

  ```java
  public class TestService {
      private static int a;
      private static double b;
      private static String name;
      private static Integer age;
  
      public static void main(String[] args) {
          System.out.println("Yes , JVM !");
  
          System.out.println(a);
          System.out.println(b);
          System.out.println(name);
          System.out.println(age);
      }
  }
  ```

  输出：

  ![1585399064780](images.assets/1585399064780.png)

  可以看到即使我们没有显示赋值变量的值，变量本身也会被赋值对应的数据类型初始值，例如 int 类型默认值 0 , 对象类型默认初始值 null 。

* **对对象进行必要的设置**。

  包括对象头（Object Header）信息的设置，例如这个对象是哪个类实例、如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄信息。

* 执行<init>方法，把对象按照程序的设置进行初始化，例如 `int a = 3;`   将 a 变量赋值对应的 3 , 这样一个真正的可用对象才算完全产生出来。

### 2 对象内存布局

### 3 对象访问定位